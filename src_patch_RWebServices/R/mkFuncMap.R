  
############################
# section 5: Generating java function signatures and wrapper functions
############################

## creates the java function signature based on R function signature and 
## java <-> R lookup table    
rjSigsTojSigs <- function( rjSigs, lookup ) {
    getJType <- function( rType ) {
                    thisMap <- get( rType, lookup, inherits=FALSE )
                    if (identical(thisMap@jPackage, ""))
                        res <- thisMap@jType
                    else
                        res <- paste(thisMap@jPackage, ".", thisMap@jType, sep="", collapse="")
                    res
                }
    ## map return / arg types to Java classes
    ## record funcNames
    funcNames <- character()
    for ( i in seq( along = rjSigs )) {
        rjSigs[[i]]@returnType <- getJType( rjSigs[[i]]@returnType )
        names(rjSigs[[i]]@returnType) <- mangleName(names(rjSigs[[i]]@returnType))
        if (length(rjSigs[[i]]@args)>0) {
            rjSigs[[i]]@args <- sapply( rjSigs[[i]]@args, getJType )
            names(rjSigs[[i]]@args) <- mangleName(names(rjSigs[[i]]@args))
        }
        funcNames <- c(funcNames, rjSigs[[i]]@funcName)
    }    
    ## alias duplicated function names
    appendex <- 0
    orgiNames <- funcNames
    while( any(di <- duplicated(funcNames)) ) {
        appendex <- appendex +1 
        funcNames[di] <- paste(orgiNames[di], "_", appendex, sep="")
    }
    if (appendex >0) {
        mapply(
            function(sig, funcName) { sig@funcName <- funcName },
            rjSigs, funcNames
        )
    }
    ## return modified signatures
    rjSigs
}


## inner function used by generateFunctionMap
## param:
##      rTypeInfo: a list of R function signatures
##      lookup: environment containing R <-> java data type mapping information
## return: a character vector of package names. These packages are useful for the 
##          mapping of the function signatures in rTypeInfo. Useful packages  
##          include the packages where the function's parameter or return
##          data types are defined
getDataPkgs <- function(rTypeInfo, lookup) {
    getPkg <- function( rType ) {
                pkgName <- get( rType, lookup, inherits=FALSE )@rPackage
              }
    pkgList <- lapply( rTypeInfo, function(x) {
                        paramPkgs <- unlist(sapply(x@args, getPkg))
                        returnPkg <- getPkg(x@returnType)
                        c(paramPkgs, returnPkg)
                   })
    pkgList <- unique(unlist(pkgList))
    pkgList <- pkgList[pkgList != "base"]
    ## order the packages based on package dependencies
    searchPath <- gsub("^package:", "", search())
    pkgIndex <- match(pkgList, searchPath)
    names(pkgIndex) <- pkgList
    pkgIndex <- sort(pkgIndex, decreasing=TRUE)
    names(pkgIndex) 
}   



getRWebServicesProerties <- function(mainPkg, mainService) {
    propStr <- paste(
                    "\npackage ", mainPkg, ";\n",
                    "import java.io.*;\n",
                    "import java.util.*;\n",
                    "\n/**\n",
                    "\n * ", mainService, "Properties defines the properties for ", mainService, "\n",
                    " * auto-generated by R function getRWebServicesProperties, ", date(), "\n",
                    " */\n",
                    "public class ", mainService, "Properties extends Properties\n",
                    "{\n",
                    "\tpublic ", mainService, "Properties() throws Exception\n",
                    "\t{\n",
                    "\t\tsuper();\n",
                    "\t\ttry{\n",
                    "\t\t\tload(getClass().getResourceAsStream(\"RWebServices4java.properties\"));\n",
                    "\t\t} catch(IOException e){\n",
                    "\t\t\tSystem.err.println(e.getMessage());\n",
                    "\t\t\tthrow new Exception(\"File RWebServices4java.properties not found.\");\n",
                    "\t\t}\n",
                    "\t}\n",
                    "}\n",
                    sep="", collapse="")
    propStr
}  

.generateREnv <- function(cvtName, mainPkg, renvName, rPkgList, dataPkgList) {
    libraryPart1 <-
      if (!is.na(glenv <- match(".GlobalEnv", rPkgList))) {
          rPkgList <- rPkgList[-glenv]
          paste('String rGlobalFuncDef = prop.getProperty("r.global.function");',
                'e.voidEval("source(\'" + rGlobalFuncDef + "\')");', 
                sep="\n\t\t")
      } else character(0)
    libraryPart2 <-
      if (length(rPkgList)>0) 
        paste('e.voidEval("library(\'', rPkgList, '\')");', sep="", collapse="\n\t\t")
      else character(0)
    libraryPart <-
      paste(libraryPart1, libraryPart2, sep="\n\t\t")
    sjavaCvtPart <- 
      if(length(rPkgList)>0)
        paste("importCvt(\"", dataPkgList, "\");", sep="", collapse="\n\t\t")
      else character(0)
    checkPkgList <- unique(c(rPkgList, dataPkgList))
    checkPkgList <- checkPkgList[checkPkgList != ".GlobalEnv"]
    versionPart <- 
      if (length(checkPkgList)>0) {
          pkgVersionList <- unlist(lapply(checkPkgList, 
                                          function(x) packageDescription(x)$Version))
          paste('e.voidEval("checkPkgVersion(\'',
                checkPkgList, "', '",
                pkgVersionList, '\')");\n',
                sep="", collapse="")
      } else character(0)
    paste("\npackage ", mainPkg, ";\n",
          "import java.util.*;\n",
          "import org.bioconductor.packages.rservices.RServicesEnv;\n",
          "\npublic class ", renvName, " extends RServicesEnv {\n",
          "\n\tpublic ", renvName, "(Properties prop) throws Exception {\n",
          "\t\tsuper();\n",
          '\t\te.voidEval("', cvtName, '()");\n',
          "\t\t", libraryPart, "\n",
          "\t\t", sjavaCvtPart, "\n",
          "\t\t", versionPart, "\n",
          "\t}\n",
          "}\n",
          sep="", collapse="")
}

setGeneric("generateREnv",
           function(typeMode, ...) standardGeneric("generateREnv"),
           signature=c("typeMode"))

setMethod("generateREnv",
          signature=signature(typeMode="robject"),
          function(typeMode, ...) .generateREnv("regAddonCvt", ...))

setMethod("generateREnv",
          signature=signature(typeMode="javalib"),
          function(typeMode, ...) .generateREnv("regAddonCvt2", ...))

setGeneric("generateJavaWrapper", function(deployMode, ...) standardGeneric("generateJavaWrapper"))   
setGeneric("generateMainJavaAPI", function(deployMode, typeMode, ...) standardGeneric("generateMainJavaAPI")) 
            
## create the java wrapper function for functions of a R pakcage and writes it in file
## param:
##      rTypeInfo: a list of R function signatures, all belong to the same package
##      jTypeInfo: a list of java function signatures, corresponding to rTypeInfo
##      rPkg:  name of the R package that functions represented by rTypeInfo belong to
##      jPkg:  java package name; this package contains a java class named
##              mainJKlass, which contains the java mapping of all rTypeInfo
##      mainJKlass:  a java class name, which contains the java mapping of all rTypeInfo
## return: NULL
## details: generate jPkg in the current working directory, generate mainJKlass in
##          in jPkg.
setMethod("generateJavaWrapper", signature(deployMode="demo"), 
        function(deployMode, rTypeInfo, jTypeInfo, rPkg, jPkg, mainJKlass) {
    jPkgPath <- gsub(".", .Platform$file.sep, jPkg, fixed=TRUE) 
    outputFile=file.path(".", jPkgPath, paste(mainJKlass, ".java", sep="", collapse=""))
    if (!file.exists(outputFile))  
        dir.create(jPkgPath, showWarnings=FALSE, recursive=TRUE)
    if (rPkg == ".GlobalEnv") {
        cat("===============================================================\n")
        cat("WARNING-WARNING-WARNING-WARNING-WARNING-WARNING-WARNING-WARNING\n")
        cat("It seems that you have defined this function/method in .GlobalEnv:\n")
        print(rTypeInfo)
        cat("You have to define it in a file so that we can source it when we start the embeded R from Java. We assume the file path is the associate value of 'r.global.function' in file 'RWebServices.properties'. If you want to use another file, please modify '", outputFile, "'.\n")
        cat("WARNING-WARNING-WARNING-WARNING-WARNING-WARNING-WARNING-WARNING\n")
        cat("===============================================================\n")   
    } 
    func_doc <- getFunctionDoc(rPkg, rTypeInfo)
    
    funcDefList <- mapply( function(JtypeSig, RtypeSig) {
        param_doc <- paste(RtypeSig@funcName, names(RtypeSig@args), sep="_")
        param_doc <- paste("\t* @param ", names(JtypeSig@args), "\t", 
            mget(param_doc, func_doc), "\n", sep="", collapse="")
        funcDef <- paste("\n\t/**\n", 
            "\t* ", get(RtypeSig@funcName, func_doc), "\n",
            "\t*\n",
            param_doc,
            "\t* @return\t", 
            get(paste(RtypeSig@funcName, "return", sep="_", collapse=""), func_doc), 
            "\n",
            "\t*/\n",
            "\tpublic ", JtypeSig@returnType, " ", JtypeSig@funcName, "(",
            paste(JtypeSig@args, names(JtypeSig@args), sep=" ", collapse=", "),
            ", RServicesEnv e) throws Exception {\n",
            "\t\tObject ans=e.call(\"", RtypeSig@funcName, "\", new Object[]{",
            paste(names(JtypeSig@args), sep="", collapse=", "),
            "});\n", 
            "\t\t", JtypeSig@returnType, " res=(", JtypeSig@returnType, ")ans;\n",
            "\t\treturn res;\n",
            "\t}\n", sep="", collapse="")
        funcDef
    }, jTypeInfo, rTypeInfo )
    funcDefList <- paste(funcDefList, sep="", collapse="\n")
    myServ <- paste("\npackage ", jPkg, ";\n",
        "import org.bioconductor.packages.rservices.RServicesEnv;\n",
        "import java.util.*;\n",
        "\n\npublic class ", mainJKlass, " {\n",
        funcDefList,
        "}\n", sep="", collapse="")

    cat(myServ, file=outputFile)
    return()
})

## create the main java API
## param:
##      jTypeInfoByPkg: 
##              A list, each element is an instance of S4 class "RJavaPkgFunction".
##              Each element (e) represent the java mapping of functions in a R
##              package. e@rPackage is the R package name, e@javaClass is the 
##              full name (with package name in front) of the java class which
##              contains all java mapping functions of the functions in the R 
##              package, e@javaTypeInfo is the function siguatures of those java
##              mapping functions, it is a list of "RJavaSignature" class instance
##      dataPkgList: a character vector of package names. These packages are  
##          useful for the mapping of the function signatures in rTypeInfo.  
##          Useful packages include the packages where the function's parameter 
##          or return data types are defined
##      mainServ: class name of the main java API 
## return: NULL
setMethod("generateMainJavaAPI", signature(deployMode="demo"), 
          function(deployMode, typeMode, jTypeInfoByPkg, dataPkgList, 
		mainServ, wsdlStyle, wsdlUse) {
    mainPkg <- ServToServPkg(mainServ, deployMode)
    ## generate ${mainServ}REnv.java
    renvName <- paste(mainServ, "REnv", sep="", collapse="")
    rPkgList <- unique(unlist(lapply(jTypeInfoByPkg, function(x) x@rPackage)))
    renv <- generateREnv(typeMode, mainPkg, renvName, rPkgList, dataPkgList)
    ## generate main API
    privateFieldName <- paste("my", mangleName(rPkgList), sep="")
    jKlassList <- sapply(jTypeInfoByPkg, function(x) x@javaClass)
    fieldList <- paste("\tprivate ", jKlassList, " ", privateFieldName, ";\n",
                    sep="", collapse="")
    constructorPart <- paste("\t\t", privateFieldName, "= new ", jKlassList, "();\n", 
                        sep="", collapse="")
    funcPart <- mapply(function(pkgFuncList, privateField) {
        rPkg <- pkgFuncList@rPackage
        funcDefList <- lapply(pkgFuncList@javaTypeInfo, 
            function(JtypeSig) {
                funcNameInAPI <- getApiFuncName(rPkg, JtypeSig)
                funcDef <- paste(
                    "\tpublic ", JtypeSig@returnType, " ", funcNameInAPI, "(",
                    paste(JtypeSig@args, names(JtypeSig@args), sep=" ", collapse=", "),
                    ") throws java.rmi.RemoteException {\n",   
                    "\t\t", JtypeSig@returnType, " ans=null;\n",
                    "\t\ttry {\n",
                    "\t\t\t", 
                    " ans= ", privateField, ".", JtypeSig@funcName, "( ",
                    paste(names(JtypeSig@args), sep="", collapse=", "),
                    ", e );\n",
                    "\t\t} catch (Exception rex) {\n",
                    "\t\t\tthrow new java.rmi.RemoteException(rex.getMessage());\n",
                    "\t\t}\n",
                    "\t\treturn ans;\n",
                    "\t}\n", sep="", collapse="")
                funcDef
            }
        )
        paste(funcDefList, sep="", collapse="")
    }, jTypeInfoByPkg, privateFieldName)
    wholeClassDef <- function(mainPkg, mainServ, servClassName, interfacePart) {    
        paste("\npackage ", mainPkg, ";\n",
            "import java.util.*;\n",
            "\n\npublic class ", servClassName, interfacePart, " {\n",
            "\tprivate ", renvName, " e;\n",
            fieldList, 
            "\n\tpublic ", servClassName, "() throws Exception {\n",  
            "\t\t", mainServ, "Properties prop = new ", mainServ, "Properties();\n",
            "\t\te=new ", renvName, "(prop);\n",
            constructorPart,
            "\t}\n",
            paste(funcPart, sep="", collapse=""),
            "}\n", sep="", collapse="")
    }
    localServ <- wholeClassDef(mainPkg, mainServ, mainServ, "")
    wsImplName <- paste(mainServ, "SoapBindingImpl", sep="", collapse="")
    ## try to create the webservice implementation file
    ## This file will replace the webservice implementation file being generated
    ## by the  WSDL2java tool of Apache Axis (v1.2 to 1.4). 
    ## Therefore the class name and the
    ## interface name need to be the same as Axis's outputs.
    ## Unfortunately, the interface name given by Axis depends on  
    ## the value of argument --style and --use in the call to WSDL2java
    ## if DOCUMENT-LITERAL or RPC-ENCODED then interfaceName=<mainService>
    ## if WRAPPED-LITERAL then 
    ##    if any function has the same name as the package
    ##    then interfaceName=<mainService>_PortType
    ##    else interfaceName=<mainService>
    ## I didn't check other options cauz they are not as popular as the above opts.
    if (identical(toupper(wsdlStyle), "WRAPPED")) {
    	funcNameList <- unlist(lapply(jTypeInfo, function(JtypeSig) JtypeSig@funcName))
	if(mainServ %in% funcNameList)	
		interfaceShortName <- paste(capName(mainServ), "_PortType", sep="", collapse="")
	else
		interfaceShortName <- capName(mainServ)
    } else {
	interfaceShortName <- capName(mainServ)
    }
    interfacePart <- paste(" implements ", mainPkg, ".", interfaceShortName, sep="", collapse="")
    webServ <- wholeClassDef(mainPkg, mainServ, wsImplName, interfacePart)
    ## generate RWebServicesProperties.java
    propFile <- getRWebServicesProerties(mainPkg, mainServ)
    ## write everything to file
    mainPkg <- gsub(".", .Platform$file.sep, mainPkg, fixed=TRUE)   
    outputFile1 <- file.path(".", mainPkg, paste(mainServ, ".java", sep="", collapse=""))
    outputFile2 <- file.path(".", mainPkg, paste(wsImplName, ".java.bak", sep="", collapse=""))
    outputFile3 <- file.path(".", mainPkg, paste(mainServ, "Properties.java", sep="", collapse=""))
    outputFile4 <- file.path(".", mainPkg, paste(renvName, ".java", sep="", collapse=""))
    if (!file.exists(outputFile1))
        dir.create(mainPkg, showWarnings=FALSE, recursive=TRUE)
    cat(localServ, file=outputFile1)
    cat(webServ, file=outputFile2)
    cat(propFile, file=outputFile3)
    cat(renv, file=outputFile4)
    return()
} )   

## create the java wrapper function for functions of a R pakcage and writes it in file
## These java wrapper functions serve as JMS (Java Message Service) producers.
## 
## param:
##      rTypeInfo: a list of R function signatures, all belong to the same package
##      jTypeInfo: a list of java function signatures, corresponding to rTypeInfo
##      rPkg:  name of the R package that functions represented by rTypeInfo belong to
##      jPkg:  java package name; this package contains a java class named
##              mainJKlass, which contains the java mapping of all rTypeInfo
##      mainJKlass:  a java class name, which contains the java mapping of all rTypeInfo
## return: NULL
## details: generate jPkg in the current working directory, generate mainJKlass in
##          in jPkg.
setMethod("generateJavaWrapper", signature(deployMode="jms"), 
    function(deployMode, rTypeInfo, jTypeInfo, rPkg, jPkg, mainJKlass) 
{
    jPkgPath <- gsub(".", .Platform$file.sep, jPkg, fixed=TRUE) 
    outputFile=file.path(".", jPkgPath, paste(mainJKlass, ".java", sep="", collapse=""))
    if (!file.exists(outputFile))  
        dir.create(jPkgPath, showWarnings=FALSE, recursive=TRUE)
    func_doc <- getFunctionDoc(rPkg, rTypeInfo)
    pkg_version <- ifelse(identical(rPkg, ".GlobalEnv"), "", 
                        packageDescription(rPkg)$Version)
    funcDefList <- mapply( function(JtypeSig, RtypeSig) {
        param_doc <- paste(RtypeSig@funcName, names(RtypeSig@args), sep="_")
        param_doc <- paste("\t* @param ", names(JtypeSig@args), "\t", 
            mget(param_doc, func_doc), "\n", sep="", collapse="")
        funcDef <- paste("\n\t/**\n", 
            "\t* ", get(RtypeSig@funcName, func_doc), "\n",
            "\t*\n",
            param_doc,
            "\t* @return\t", 
            get(paste(RtypeSig@funcName, "return", sep="_", collapse=""), func_doc), 
            "\n",
            "\t*/\n",
            "\tpublic ", JtypeSig@returnType, " ", JtypeSig@funcName, "(\n",
            paste("\t\t\t", JtypeSig@args, names(JtypeSig@args), ",\n", sep=" ", collapse=""),
            "\t\t\t ", primaryDataPkg(), ".RServicesConnection connection) throws Exception {\n",
            "\t\tObject ans = connection.call(\"", RtypeSig@funcName, "\", \n",
            "\t\t\t\tnew Object[]{",
            paste(names(JtypeSig@args), sep="", collapse=", "), 
            "},\n",
            "\t\t\t\t\"", rPkg, "\", \"", pkg_version, "\");\n",  
            "\t\t", JtypeSig@returnType, " res = (", JtypeSig@returnType, ")ans;\n",
            "\t\treturn res;\n",
            "\t}\n", sep="", collapse="")
        funcDef
    }, jTypeInfo, rTypeInfo )
    funcDefList <- paste(funcDefList, sep="", collapse="\n")
    myServ <- paste("\npackage ", jPkg, ";\n",
        "import javax.jms.*;\n",
        "import java.util.*;\n",
        "\npublic class ", mainJKlass, " {\n",
        funcDefList,
        "}\n", sep="", collapse="")
    cat(myServ, file=outputFile)
    return()
})

## create the main java API
## param:
##      jTypeInfoByPkg: 
##              A list, each element is an instance of S4 class "RJavaPkgFunction".
##              Each element (e) represent the java mapping of functions in a R
##              package. e@rPackage is the R package name, e@javaClass is the 
##              full name (with package name in front) of the java class which
##              contains all java mapping functions of the functions in the R 
##              package, e@javaTypeInfo is the function siguatures of those java
##              mapping functions, it is a list of "RJavaSignature" class instance
##      dataPkgList: a character vector of package names. These packages are  
##          useful for the mapping of the function signatures in rTypeInfo.  
##          Useful packages include the packages where the function's parameter 
##          or return data types are defined
##      mainServ: class name of the main java API 
## return: NULL
setMethod("generateMainJavaAPI", signature(deployMode="jms"),
function(deployMode, typeMode, jTypeInfo, jKlass, mainServ, wsdlStyle, wsdlUse) {
    mainPkg <- ServToServPkg(mainServ, deployMode)
    funcDefList <- lapply(jTypeInfo, 
            function(JtypeSig) {
                funcDef <- paste(
                    "\tpublic ", JtypeSig@returnType, " ", JtypeSig@funcName, "(",
                    paste(JtypeSig@args, names(JtypeSig@args), sep=" ", collapse=", "),
                    ") throws java.rmi.RemoteException {\n",   
                    "\t\t", JtypeSig@returnType, " ans=null;\n",
                    "\t\ttry {\n",
                    "\t\t\tConnection jmsConnection = connectionFactory.createConnection();\n", 
                    "\t\t\tRServicesConnection connection = ",
                    "new RServicesConnection( jmsConnection, queueName, timeout );\n", 
                    "\t\t\t",
                    " ans= my", mainServ, ".", JtypeSig@funcName, "( ",
                    paste(names(JtypeSig@args), sep="", collapse=", "),
                    ", connection );\n",
                    "\t\t} catch (Exception rex) {\n",
                    "\t\t\tthrow new java.rmi.RemoteException(rex.getMessage());\n",
                    "\t\t}\n",
                    "\t\treturn ans;\n",
                    "\t}\n", sep="", collapse="")
                funcDef
            }
        )
    funcPart <- paste(funcDefList, sep="", collapse="")
    wholeClassDef <- function(mainPkg, mainServ, servClassName, interfacePart) {    
        paste("\npackage ", mainPkg, ";\n",
            "import org.apache.activemq.ActiveMQConnectionFactory;\n",
            "import javax.jms.ConnectionFactory;\n",  
            "import javax.jms.Connection;\n",
            "import ", primaryDataPkg(), ".RServicesConnection;\n",                         
            "import java.util.*;\n",
            "\n\npublic class ", servClassName, interfacePart, " {\n",
            "\tprivate ConnectionFactory connectionFactory;\n",
            "\tprivate String queueName;\n",
            "\tprivate long timeout;\n",
            "\tprivate ", jKlass, " my", mainServ, ";\n", 
            "\n\tpublic ", servClassName, "() throws Exception {\n",
            "\t\t", mainServ, "Properties prop = new ", mainServ, "Properties();\n",
            "\t\tString jmsUrl = \"tcp://\" + prop.getProperty(\"jms.host\")", 
            " + \":\"+prop.getProperty(\"jms.port\");\n",
            "\t\tString timeoutStr = prop.getProperty(\"jms.timeout\", \"6000\");\n",
            "\t\ttimeout=(new Long(timeoutStr)).longValue();\n",
            "\t\tconnectionFactory = new ActiveMQConnectionFactory(jmsUrl);\n",
            "\t\tqueueName = prop.getProperty(\"jms.queue\", \"BIOC\");\n",
            "\t\tmy", mainServ, "= new ", jKlass, "();\n",
            "\t}\n",
            paste(funcPart, sep="", collapse=""),
            "}\n", sep="", collapse="")
    }
    localServ <- wholeClassDef(mainPkg, mainServ, mainServ, "")
    wsImplName <- paste(mainServ, "SoapBindingImpl", sep="", collapse="")
    ## try to create the webservice implementation file
    ## This file will replace the webservice implementation file being generated
    ## by the  WSDL2java tool of Apache Axis (v1.2 to 1.4). 
    ## Therefore the class name and the
    ## interface name need to be the same as Axis's outputs.
    ## Unfortunately, the interface name given by Axis depends on  
    ## the value of argument --style and --use in the call to WSDL2java
    ## if DOCUMENT-LITERAL or RPC-ENCODED then interfaceName=<mainService>
    ## if WRAPPED-LITERAL then 
    ##    if any function has the same name as the package
    ##    then interfaceName=<mainService>_PortType
    ##    else interfaceName=<mainService>
    ## I didn't check other options cauz they are not as popular as the above opts.
    if (identical(toupper(wsdlStyle), "WRAPPED")) {
    	funcNameList <- unlist(lapply(jTypeInfo, function(JtypeSig) JtypeSig@funcName))
	if(mainServ %in% funcNameList)	
		interfaceShortName <- paste(capName(mainServ), "_PortType", sep="", collapse="")
	else
		interfaceShortName <- capName(mainServ)
    } else {
	interfaceShortName <- capName(mainServ)
    }
    interfacePart <- paste(" implements ", mainPkg, ".", interfaceShortName, sep="", collapse="")
    webServ <- wholeClassDef(mainPkg, mainServ, wsImplName, interfacePart)
    propFile <- getRWebServicesProerties(mainPkg, mainServ)
    mainPkg <- gsub(".", .Platform$file.sep, mainPkg, fixed=TRUE)   
    outputFile1 <- file.path(".", mainPkg, paste(mainServ, ".java", sep="", collapse=""))
    outputFile2 <- file.path(".", mainPkg, paste(wsImplName, ".java.bak", sep="", collapse=""))
    outputFile4 <- file.path(".", mainPkg, paste(mainServ, "Properties.java", sep="", collapse=""))
    if (!file.exists(outputFile1))
        dir.create(mainPkg, showWarnings=FALSE, recursive=TRUE)
    cat(localServ, file=outputFile1)
    cat(webServ, file=outputFile2)
    cat(propFile, file=outputFile4)
    return()
})

generateWorker <- function(typeMode, jTypeInfoByPkg, dataPkgList) {
    rPkgList <- unique(unlist(lapply(jTypeInfoByPkg, function(x) x@rPackage)))
    mainPkg <- rworkerPkg()
    ## generate WorkerREnv.java
    renvName <- "RWorkerREnv"
    renv <- generateREnv(typeMode, mainPkg, renvName, rPkgList, dataPkgList)
    ## generate RWebServicesProperties.java
    propFile <- getRWebServicesProerties(mainPkg, "RWorker")
    rworker <- paste(
                    "package ", mainPkg, ";\n",
                    "import javax.jms.*;\n",
                    "import org.apache.activemq.ActiveMQConnectionFactory;\n",
                    "import org.bioconductor.packages.rservices.*;\n",
                    "import java.util.*;\n",
                    "\npublic class RWorker {\n",
                    "\n\tpublic static void main (String[] args) throws Exception {\n",
                    "\t\tRWorkerProperties prop = new RWorkerProperties();\n",
                    "\t\t", renvName, " e = new ", renvName, "(prop);\n",
                    "\t\tString jmsUrl = \"tcp://\" + prop.getProperty(\"jms.host\")", 
                        " + \":\" + prop.getProperty(\"jms.port\");\n",
		    "\t\tString queueName = prop.getProperty(\"jms.queue\", \"BIOC\");\n",
                    "\t\tConnection connection = null;\n",
                    "\t\tObject ans = null;\n",
                    "\t\ttry{\n",
                    "\t\t\tActiveMQConnectionFactory connectionFactory = ",
                    "new ActiveMQConnectionFactory(jmsUrl);\n",
                    "\t\t\tconnection = connectionFactory.createConnection();\n",
                    "\t\t\tconnection.start();\n",
                    "\t\t\tSession session = connection.createSession(true, 0);\n",
                    "\t\t\tDestination destination = session.createQueue(queueName);\n",
                    "\t\t\tMessageConsumer consumer = session.createConsumer(destination);\n",
                    "\t\t\tMessageProducer producer = session.createProducer(null);\n",
                    "\t\t\twhile(true) {\n",
                    "\t\t\t\tMessage message = consumer.receive(1);\n",
                    "\t\t\t\tif (message != null) {\n",
                    "\t\t\t\t\tObject[] rInputs = (Object[])(((ObjectMessage)message).getObject());\n",
                    "\t\t\t\t\tString rPkgName = message.getStringProperty(\"package\");\n",
                    "\t\t\t\t\tString rFunctionName = message.getStringProperty(\"function\");\n",
                    "\t\t\t\t\ttry {\n",
                    "\t\t\t\t\t\tans = e.call(rFunctionName, rInputs);\n", 
                    "\t\t\t\t\t} catch (Exception rex) {\n",
                    "\t\t\t\t\t\tans = rex;\n",
                    "\t\t\t\t\t}\n",
                    "\t\t\t\t\tMessage replyMsg = session.createObjectMessage( new Object[]{ans} );\n",
		    "\t\t\t\t\ttry {\n",
                    "\t\t\t\t\t\tproducer.send(message.getJMSReplyTo(), replyMsg);\n",
                    "\t\t\t\t\tsession.commit();\n",
		    "\t\t\t\t\t} catch (Exception rex) {\n",
		    "\t\t\t\t\t\tSystem.err.println(rex.getMessage());\n",
		    "\t\t\t\t\t}\n",
                    "\t\t\t\t}\n",
                    "\t\t\t}\n",
                    "\t\t} catch (Exception jmsex) {\n",                                      
                    "\t\t\tthrow jmsex;\n",
                    "\t\t} finally {\n",
                    "\t\t\tif (connection != null)\n",
                    "\t\t\t\tconnection.close();\n",
                    "\t\t}\n",
                    "\t}\n",
                    "}\n",
                    sep="", collapse="")

    mainPkg <- gsub(".", .Platform$file.sep, mainPkg, fixed=TRUE)   
    outputFile1 <- file.path(".", mainPkg, "RWorker.java")
    outputFile2 <- file.path(".", mainPkg, "RWorkerProperties.java")
    outputFile3 <- file.path(".", mainPkg, paste(renvName, ".java", sep="", collapse=""))
    if (!file.exists(outputFile1))
        dir.create(mainPkg, showWarnings=FALSE, recursive=TRUE)
    cat(rworker, file=outputFile1)
    cat(propFile, file=outputFile2)
    cat(renv, file=outputFile3)
    return()
}
    
## main function; entrance of all other functions
## SIDE EFFECT: In the current directory, generate java mappings for all 
##              input R function signatures, the data types mappng for 
##              function argument and return values, a java API to invoke
##              all function mappings, and a java client for testing (if genTest=T)
## param:
##      rTypeInfo: a list of R function signatures
##      genTest: TRUE if want to generate java client for test, FALSE otherwise
##      mainService: main java API class name (short name, without package)
## return: NULL
generateFunctionMap <- function(rTypeInfo, genTest=TRUE, 
                        workDir=getwd(), verbose=FALSE, 
                        deployModeName="jms", typeModeName="javalib", 
			wsdlStyle="WRAPPED", wsdlUse="LITERAL",
			extraClasses="", pkgRoot="org.bioconductor", ...) {
    updateJavaPkgRoot(pkgRoot)
    currwd <- getwd()
    workDir <- file.path(workDir, "src")
    dir.create(workDir, showWarnings=FALSE, recursive=TRUE)
    setwd(workDir)
    on.exit(setwd(currwd))
    deployModeName <- tolower(deployModeName)  
    if (identical(deployModeName, "demo")) {
        deployMode <- new("demo")
    } else if (identical(deployModeName, "jms")) {
        deployMode <- new("jms")
    } else {
        stop("Invalid deploy mode:", deployModeName, ". Mode should be 'demo' for single user mode or ",
            "'jms' for multi-user mode.")
    }
    typeModeName <- tolower(typeModeName)  
    if (identical(typeModeName, "robject")) {
        typeMode <- new("robject")
    } else if (identical(typeModeName, "javalib")) {
        typeMode <- new("javalib")
    } else {
        stop("Invalid type mode:", typeModeName, 
        ". Mode should be 'robject' for mapping R types to custimized Java Classes or ",
        "'javalib' for mapping R types to existing Java Classes.")
    }        

    ## resolve all data type mapping
    if (verbose)
        cat("********************************************\n",
            "***   resolve all data type mapping    *****\n",
            "********************************************\n")
    lookup <-newLookup(typeMode)
    buildInType <- ls(lookup)
    if (verbose && length(extraClasses)>0)
	cat(">>>>>> Generate data map for extraClasses: \n")
    extraClasses <- strsplit(paste(",", extraClasses, ",", sep="", collapse=""),
			"[ ]*,[ ]*")
    extraClasses <- unlist(extraClasses)
    extraClasses <- extraClasses[extraClasses!=""]
    for ( thisExtraClass in extraClasses ) {
	if (verbose)
		cat("\tdata map for: ", thisExtraClass, "\n")
	lookup <- generateDataMap(thisExtraClass, javaToR=TRUE, 
			deployMode=deployMode, typeMode=typeMode, lookup=lookup)
	lookup <- generateDataMap(thisExtraClass, javaToR=FALSE, 
			deployMode=deployMode, typeMode=typeMode, lookup=lookup)
    }
    lookup <- rjSigsToRJMap( rTypeInfo, lookup=lookup, deployMode=deployMode, 
                    typeMode=typeMode, verbose=verbose)
    allType <- ls(lookup)
    addonType <- allType[!(allType %in% buildInType)]

    ## get the R packages that the functions represented by rTypeInfo belong to 
    rPkgList <- unlist(lapply(rTypeInfo, function(x) {
                    rFunName <- x@funcName
                    searchPath <- search()
                    searchPath <- c(searchPath[-1], searchPath[1])
                    for (pkg in searchPath) {
                        if (exists(rFunName, where=pkg, mode="function", inherits=FALSE))
                            return(sub("package:", "", pkg, fixed=TRUE))
                    }
                   stop("Error in generateFunctionMap: Can't find environment for ", rFunName, "\n")
                } ))

    ## generate java wrappers for all the functions represented by rTypeInfo
    ## and group them in a package layout
    if (verbose)
            cat("********************************************\n",
                "****     resolve function mapping      *****\n",
                "********************************************\n")
    groupByPkg <- split(rTypeInfo, rPkgList)
    
    javaWrapperForPkg <- function( rTypeInfo, rPkg) {
            if (verbose)
                cat(">>>>>> Generate function map for R package: ", rPkg, "\n")
            jTypeInfo <- rjSigsTojSigs( rTypeInfo, lookup)
            if (verbose) {
                cat(">> (1) java function signature:\n")
                print(jTypeInfo)
            }
            jPkg <- rPkgTojPkg(rPkg) 
            mainJKlass <- rPkgToMainJKlass(rPkg)
            generateJavaWrapper(deployMode, rTypeInfo, jTypeInfo, rPkg, jPkg, mainJKlass)
            fullJKlass <- paste(jPkg, mainJKlass, sep=".")
            new("RJavaPkgFunctions", rPackage=rPkg, javaClass=fullJKlass,
                    javaTypeInfo=jTypeInfo)
    }
    jTypeInfoByPkg <- mapply(javaWrapperForPkg, groupByPkg, names(groupByPkg))
    
    if (verbose)
        cat("********************************************\n",
                "****       generate main Java API      *****\n")
    dataPkgList <- getDataPkgs(rTypeInfo, lookup)
    ## get the R packages that define the data types used by rTypeInfo
    if (is(deployMode, "demo")) {
        mainService <- "Demo"
        generateMainJavaAPI(deployMode, typeMode, jTypeInfoByPkg, dataPkgList, 
			mainService, wsdlStyle, wsdlUse)
        if (genTest)
          generateFuncTest(deployMode, jTypeInfoByPkg, mainService, verbose)
        generateDataTest(mainService, ServToServPkg(mainService, deployMode), lookup, addonType, verbose)
    } else {                               ## jms mode
       lapply(jTypeInfoByPkg,
            function(currTypeInfoByPkg) {
                if (verbose)
                    cat("****     for package ", currTypeInfoByPkg@rPackage, "  **********\n")
                mainService <- rPkgToService(currTypeInfoByPkg@rPackage)
                pkgMainJavaClass <- currTypeInfoByPkg@javaClass
                jTypeInfo <- currTypeInfoByPkg@javaTypeInfo
                generateMainJavaAPI(deployMode, typeMode, jTypeInfo, 
				pkgMainJavaClass, mainService, wsdlStyle, wsdlUse)
                if (genTest)
                  generateFuncTest(deployMode, jTypeInfo, mainService, verbose)
            }
        )
        generateWorker(typeMode, jTypeInfoByPkg, dataPkgList)
        generateDataTest("RWorker", rworkerPkg(), lookup, addonType, verbose)
    }
    if (verbose)
        cat("***************      DONE     *************\n")
    return(jTypeInfoByPkg)
}   
 
